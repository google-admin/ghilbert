kind wff;
/* comment with /* nesting */ */
/* ordinary comment */
kind val;
var ph ps ch: wff;
term -> wff wff: wff;
axiom ax-1: -> ph (-> ps ph);
axiom ax-2: -> (-> ph (-> ps ch)) (-> (-> ph ps) (-> ph ch));
axiom ax-mp (ph) (-> ph ps): ps;

theorem a1i (hyp: ph): -> ps ph ::(
    ax-mp hyp ax-1
)

theorem a2i (hyp: -> ph (-> ps ch)): -> (-> ph ps) (-> ph ch) ::(
    ax-mp hyp ax-2
)

theorem mpd
    (hyp1: -> ph ps)
    (hyp2: -> ph (-> ps ch)):
    -> ph ch
::(
    ax-mp hyp1 (a2i hyp2)
)

/* This theorem requires a result line in order to check, otherwise
   one of the subterms of the first ax-1 is left unspecified. */
theorem id: -> ph ph ::(
    ax-1
    [-> ph (-> ph ph)]
    mpd _ ax-1
)

/* Quantification. The universal quantifier takes a lambda term as its argument. */
term A. (val->wff): wff;
binder x: val;
axiom ax-gen (ph): A. (\ x ph);
axiom ax-5: -> (A. (\ x -> ph ps)) (-> (A. (\ x ph)) (A. (\ x ps)));
var a b c: val;
term = val val: wff;
axiom eqid: = a a;

/* Here we check that a bound variable in an intermediate result needn't be specified. */
theorem foo-lemma (hyp1: ph) (hyp2: A. (\ x = x x)): ph ::(hyp1)
theorem foo: -> ph ph ::(
    foo-lemma (id) (ax-gen eqid)
)

/* This theorem shouldn't check:
theorem bad: -> ph (-> ps ch) ::(ax-1)
*/
